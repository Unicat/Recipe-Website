{"version":3,"sources":["../../../../node_modules/split/test/split.asynct.js"],"names":["es","require","it","style","d","split","join","fs","Stream","Readable","spec","through","stringStream","exports","test","readme","__filename","expected","readFileSync","cs","actual","ended","x","a","write","l","push","trim","end","forEach","v","k","like","process","nextTick","done","validate","writable","createReadStream","flags","pipe","line","toUpperCase","equal","str","reduce","splitBy","cs1","cs2","y","delimeter","arr","piece","concat"],"mappings":";;AAAA,IAAIA,KAAKC,QAAQ,cAAR,CAAT;AAAA,IACIC,KAAKD,QAAQ,OAAR,EAAiBE,KAAjB,CAAuB,QAAvB,CADT;AAAA,IAEIC,IAAIH,QAAQ,OAAR,CAFR;AAAA,IAGII,QAAQJ,QAAQ,IAAR,CAHZ;AAAA,IAIIK,OAAOL,QAAQ,MAAR,EAAgBK,IAJ3B;AAAA,IAKIC,KAAKN,QAAQ,IAAR,CALT;AAAA,IAMIO,SAASP,QAAQ,QAAR,EAAkBO,MAN/B;AAAA,IAOIC,WAAWR,QAAQ,QAAR,EAAkBQ,QAPjC;AAAA,IAQIC,OAAOT,QAAQ,aAAR,CARX;AAAA,IASIU,UAAUV,QAAQ,SAAR,CATd;AAAA,IAUIW,eAAeX,QAAQ,kBAAR,CAVnB;;AAYAY,QAAS,iCAAT,IAA8C,UAAUC,IAAV,EAAgB;AAC5D,MAAIC,SAAST,KAAKU,UAAL,CAAb;AAAA,MACIC,WAAWV,GAAGW,YAAH,CAAgBH,MAAhB,EAAwB,OAAxB,EAAiCV,KAAjC,CAAuC,IAAvC,CADf;AAAA,MAEIc,KAAKd,OAFT;AAAA,MAGIe,SAAS,EAHb;AAAA,MAIIC,QAAQ,KAJZ;AAAA,MAKIC,IAAIZ,KAAKS,EAAL,EAASR,OAAT,EALR;;AAOA,MAAIY,IAAI,IAAIf,MAAJ,EAAR;;AAEAe,IAAEC,KAAF,GAAU,UAAUC,CAAV,EAAa;AACrBL,WAAOM,IAAP,CAAYD,EAAEE,IAAF,EAAZ;AACD,GAFD;AAGAJ,IAAEK,GAAF,GAAQ,YAAY;;AAEhBP,YAAQ,IAAR;AACAJ,aAASY,OAAT,CAAiB,UAAUC,CAAV,EAAYC,CAAZ,EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAGD,CAAH,EACE5B,GAAGkB,OAAOW,CAAP,CAAH,EAAcC,IAAd,CAAmBF,CAAnB;AACH,KARD;AASA;AACAG,YAAQC,QAAR,CAAiB,YAAY;AAC3BpB,WAAKqB,IAAL;AACAb,QAAEc,QAAF;AACD,KAHD;AAIH,GAjBD;AAkBAb,IAAEc,QAAF,GAAa,IAAb;;AAEA9B,KAAG+B,gBAAH,CAAoBvB,MAApB,EAA4B,EAACwB,OAAO,GAAR,EAA5B,EAA0CC,IAA1C,CAA+CrB,EAA/C;AACAA,KAAGqB,IAAH,CAAQjB,CAAR;AAED,CApCD;;AAsCAV,QAAS,+BAAT,IAA4C,UAAUC,IAAV,EAAgB;AAC1D,MAAIC,SAAST,KAAKU,UAAL,CAAb;AAAA,MACIC,WAAWV,GAAGW,YAAH,CAAgBH,MAAhB,EAAwB,OAAxB,EAAiCV,KAAjC,CAAuC,IAAvC,CADf;AAAA,MAEIc,KAAKd,MAAM,UAAUoC,IAAV,EAAgB;AAAE,WAAOA,KAAKC,WAAL,EAAP;AAA2B,GAAnD,CAFT;AAAA,MAGItB,SAAS,EAHb;AAAA,MAIIC,QAAQ,KAJZ;AAAA,MAKIC,IAAIZ,KAAKS,EAAL,EAASR,OAAT,EALR;;AAOA,MAAIY,IAAI,IAAIf,MAAJ,EAAR;;AAEAe,IAAEC,KAAF,GAAU,UAAUC,CAAV,EAAa;AACrBL,WAAOM,IAAP,CAAYD,EAAEE,IAAF,EAAZ;AACD,GAFD;AAGAJ,IAAEK,GAAF,GAAQ,YAAY;;AAEhBP,YAAQ,IAAR;AACAJ,aAASY,OAAT,CAAiB,UAAUC,CAAV,EAAYC,CAAZ,EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAGD,CAAH,EACE5B,GAAGkB,OAAOW,CAAP,CAAH,EAAcY,KAAd,CAAoBb,EAAEH,IAAF,GAASe,WAAT,EAApB;AACH,KARD;AASA;AACAT,YAAQC,QAAR,CAAiB,YAAY;AAC3BpB,WAAKqB,IAAL;AACAb,QAAEc,QAAF;AACD,KAHD;AAIH,GAjBD;AAkBAb,IAAEc,QAAF,GAAa,IAAb;;AAEA9B,KAAG+B,gBAAH,CAAoBvB,MAApB,EAA4B,EAACwB,OAAO,GAAR,EAA5B,EAA0CC,IAA1C,CAA+CrB,EAA/C;AACAA,KAAGqB,IAAH,CAAQjB,CAAR;AAED,CApCD;;AAsCAV,QAAS,wCAAT,IAAqD,UAAUC,IAAV,EAAgB;AACnE,MAAI8B,MAAM,MAAV;AAAA,MACI3B,WAAW2B,IAAIvC,KAAJ,CAAU,OAAV,EAAmBwC,MAAnB,CAA0BC,QAAQ,OAAR,CAA1B,EAA4C,EAA5C,CADf;AAAA,MAEIC,MAAM1C,MAAM,OAAN,CAFV;AAAA,MAGI2C,MAAM3C,MAAM,OAAN,CAHV;AAAA,MAIIe,SAAS,EAJb;AAAA,MAKIC,QAAQ,KALZ;AAAA,MAMIC,IAAIZ,KAAKqC,GAAL,EAAUpC,OAAV,EANR;AAAA,MAOIsC,IAAIvC,KAAKsC,GAAL,EAAUrC,OAAV,EAPR;;AASA,MAAIY,IAAI,IAAIf,MAAJ,EAAR;;AAEAe,IAAEC,KAAF,GAAU,UAAUC,CAAV,EAAa;AACrBL,WAAOM,IAAP,CAAYD,EAAEE,IAAF,EAAZ;AACD,GAFD;AAGAJ,IAAEK,GAAF,GAAQ,YAAY;;AAEhBP,YAAQ,IAAR;AACAJ,aAASY,OAAT,CAAiB,UAAUC,CAAV,EAAYC,CAAZ,EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAGD,CAAH,EACE5B,GAAGkB,OAAOW,CAAP,CAAH,EAAcC,IAAd,CAAmBF,CAAnB;AACH,KARD;AASA;AACAG,YAAQC,QAAR,CAAiB,YAAY;AAC3BpB,WAAKqB,IAAL;AACAb,QAAEc,QAAF;AACAa,QAAEb,QAAF;AACD,KAJD;AAKH,GAlBD;AAmBAb,IAAEc,QAAF,GAAa,IAAb;;AAEAU,MAAIP,IAAJ,CAASQ,GAAT;AACAA,MAAIR,IAAJ,CAASjB,CAAT;;AAEAwB,MAAIvB,KAAJ,CAAUoB,GAAV;AACAG,MAAInB,GAAJ;AAED,CA1CD;;AA4CA,SAASkB,OAAT,CAAkBI,SAAlB,EAA6B;AAC3B,SAAO,UAAUC,GAAV,EAAeC,KAAf,EAAsB;AAC3B,WAAOD,IAAIE,MAAJ,CAAWD,MAAM/C,KAAN,CAAY6C,SAAZ,CAAX,CAAP;AACD,GAFD;AAGD","file":"split.asynct.js","sourcesContent":["var es = require('event-stream')\n  , it = require('it-is').style('colour')\n  , d = require('ubelt')\n  , split = require('..')\n  , join = require('path').join\n  , fs = require('fs')\n  , Stream = require('stream').Stream\n  , Readable = require('stream').Readable\n  , spec = require('stream-spec')\n  , through = require('through')\n  , stringStream = require('string-to-stream')\n\nexports ['split() works like String#split'] = function (test) {\n  var readme = join(__filename)\n    , expected = fs.readFileSync(readme, 'utf-8').split('\\n')\n    , cs = split()\n    , actual = []\n    , ended = false\n    , x = spec(cs).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).like(v)\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n      })\n  }\n  a.writable = true\n\n  fs.createReadStream(readme, {flags: 'r'}).pipe(cs)\n  cs.pipe(a)\n\n}\n\nexports ['split() takes mapper function'] = function (test) {\n  var readme = join(__filename)\n    , expected = fs.readFileSync(readme, 'utf-8').split('\\n')\n    , cs = split(function (line) { return line.toUpperCase() })\n    , actual = []\n    , ended = false\n    , x = spec(cs).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).equal(v.trim().toUpperCase())\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n      })\n  }\n  a.writable = true\n\n  fs.createReadStream(readme, {flags: 'r'}).pipe(cs)\n  cs.pipe(a)\n\n}\n\nexports ['split() works with empty string chunks'] = function (test) {\n  var str = ' foo'\n    , expected = str.split(/[\\s]*/).reduce(splitBy(/[\\s]*/), [])\n    , cs1 = split(/[\\s]*/)\n    , cs2 = split(/[\\s]*/)\n    , actual = []\n    , ended = false\n    , x = spec(cs1).through()\n    , y = spec(cs2).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).like(v)\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n        y.validate()\n      })\n  }\n  a.writable = true\n\n  cs1.pipe(cs2)\n  cs2.pipe(a)\n\n  cs1.write(str)\n  cs1.end()\n\n}\n\nfunction splitBy (delimeter) {\n  return function (arr, piece) {\n    return arr.concat(piece.split(delimeter))\n  }\n}"]}