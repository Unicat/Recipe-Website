{"version":3,"sources":["../../../node_modules/from/index.js"],"names":["Stream","require","module","exports","from","source","Array","isArray","slice","i","length","emit","shift","s","ended","started","readable","writable","paused","pause","next","call","resume","on","process","nextTick","destroy"],"mappings":";AACA;;AAEA,IAAIA,SAASC,QAAQ,QAAR,CAAb;;AAEA;AACA;AACA;AACA;AACA;;AAEAC,OAAOC,OAAP,GACA,SAASC,IAAT,CAAeC,MAAf,EAAuB;AACrB,MAAGC,MAAMC,OAAN,CAAcF,MAAd,CAAH,EAA0B;AACxBA,aAASA,OAAOG,KAAP,EAAT;AACA,WAAOJ,KAAM,UAAUK,CAAV,EAAa;AACxB,UAAGJ,OAAOK,MAAV,EACE,KAAKC,IAAL,CAAU,MAAV,EAAkBN,OAAOO,KAAP,EAAlB,EADF,KAGE,KAAKD,IAAL,CAAU,KAAV;AACF,aAAO,IAAP;AACD,KANM,CAAP;AAOD;AACD,MAAIE,IAAI,IAAIb,MAAJ,EAAR;AAAA,MAAsBS,IAAI,CAA1B;AACAI,IAAEC,KAAF,GAAU,KAAV;AACAD,IAAEE,OAAF,GAAY,KAAZ;AACAF,IAAEG,QAAF,GAAa,IAAb;AACAH,IAAEI,QAAF,GAAa,KAAb;AACAJ,IAAEK,MAAF,GAAW,KAAX;AACAL,IAAEC,KAAF,GAAU,KAAV;AACAD,IAAEM,KAAF,GAAU,YAAY;AACpBN,MAAEE,OAAF,GAAY,IAAZ;AACAF,MAAEK,MAAF,GAAW,IAAX;AACD,GAHD;AAIA,WAASE,IAAT,GAAiB;AACfP,MAAEE,OAAF,GAAY,IAAZ;AACA,QAAGF,EAAEC,KAAL,EAAY;AACZ,WAAM,CAACD,EAAEC,KAAH,IAAY,CAACD,EAAEK,MAAf,IAAyBb,OAAOgB,IAAP,CAAYR,CAAZ,EAAeJ,GAAf,EAAoB,YAAY;AAC7D,UAAG,CAACI,EAAEC,KAAH,IAAY,CAACD,EAAEK,MAAlB,EACIE;AACL,KAH8B,CAA/B;AAKD;AACDP,IAAES,MAAF,GAAW,YAAY;AACrBT,MAAEE,OAAF,GAAY,IAAZ;AACAF,MAAEK,MAAF,GAAW,KAAX;AACAE;AACD,GAJD;AAKAP,IAAEU,EAAF,CAAK,KAAL,EAAY,YAAY;AACtBV,MAAEC,KAAF,GAAU,IAAV;AACAD,MAAEG,QAAF,GAAa,KAAb;AACAQ,YAAQC,QAAR,CAAiBZ,EAAEa,OAAnB;AACD,GAJD;AAKAb,IAAEa,OAAF,GAAY,YAAY;AACtBb,MAAEC,KAAF,GAAU,IAAV;AACAD,MAAEF,IAAF,CAAO,OAAP;AACD,GAHD;AAIA;;;;;;AAMAa,UAAQC,QAAR,CAAiB,YAAY;AAC3B,QAAG,CAACZ,EAAEE,OAAN,EAAeF,EAAES,MAAF;AAChB,GAFD;AAGA,SAAOT,CAAP;AACD,CAxDD","file":"index.js","sourcesContent":["\n'use strict';\n\nvar Stream = require('stream')\n\n// from\n//\n// a stream that reads from an source.\n// source may be an array, or a function.\n// from handles pause behaviour for you.\n\nmodule.exports =\nfunction from (source) {\n  if(Array.isArray(source)) {\n    source = source.slice()\n    return from (function (i) {\n      if(source.length)\n        this.emit('data', source.shift())\n      else\n        this.emit('end')\n      return true\n    })\n  }\n  var s = new Stream(), i = 0\n  s.ended = false\n  s.started = false\n  s.readable = true\n  s.writable = false\n  s.paused = false\n  s.ended = false\n  s.pause = function () {\n    s.started = true\n    s.paused = true\n  }\n  function next () {\n    s.started = true\n    if(s.ended) return\n    while(!s.ended && !s.paused && source.call(s, i++, function () {\n      if(!s.ended && !s.paused)\n          next()\n    }))\n      ;\n  }\n  s.resume = function () {\n    s.started = true\n    s.paused = false\n    next()\n  }\n  s.on('end', function () {\n    s.ended = true\n    s.readable = false\n    process.nextTick(s.destroy)\n  })\n  s.destroy = function () {\n    s.ended = true\n    s.emit('close') \n  }\n  /*\n    by default, the stream will start emitting at nextTick\n    if you want, you can pause it, after pipeing.\n    you can also resume before next tick, and that will also\n    work.\n  */\n  process.nextTick(function () {\n    if(!s.started) s.resume()\n  })\n  return s\n}\n"]}